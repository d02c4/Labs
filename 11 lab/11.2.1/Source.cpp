#include <iostream>
using namespace std;
struct LIST // структура для двунаправленного списка
{
	int inf = 0; // информационное поле типа int 
	LIST* ptrPrev = NULL; // поле хранящее адрес предыдущего элемента
	LIST* ptrNext = NULL; // поле хранящее адрес следующего элемента
};


void FillS(int* size) // функция для ввода размера двунаправленного списка пользователем
{
	cout << "Введите количество элементов списка: \t";
	cin >> (*size);
	while (*size < 1)
	{
		cout << "Введен некорректный размер списка!" << endl;
		cout << "Введите количество элементов списка: \t";
		cin >> (*size);
	}
}


LIST* Init(int size) // функция создания двунаправленного списка
{
	if (size < 1) // проверка на то, чтобы размер списка не бы меньше единицы
	{
		cout << "Список не может быть создан!";
		return 0;
	}

	LIST* ptrFirst = NULL; //  создается указатель на первый элемент, пока он никуда не указывает
	LIST* ptr = new LIST; //  выделяется динамическая память для элемента списка

	cout << "Введите 1 элемент списка: \t";
	cin >> ptr->inf; // пользователь заполняет информационное поле первого элемента
	ptrFirst = ptr; // указателю на первый элемент присваивается созданный элемент

	for (int i = 2; i <= size; i++) //  повторяем процедуру до тех пор, пока количество элементов не достигнет необходимого количества
	{
		LIST* NewOb = new LIST; // выделяется динамическая память для нового элемента списка
		LIST* ptr2 = ptr; //  создается временная переменная которая будет хранить текущее положение
		ptr->ptrNext = NewOb; // полю со следующим элементом присваивается указатель на новый объект
		ptr = ptr->ptrNext; //  переходим на следующий элелмент
		cout << "Введите " << i << " элемент списка: \t";
		cin >> ptr->inf; // пользователь заполняет информационное поле текущего объекта
		ptr->ptrPrev = ptr2; // полю с предыдущим элементом текущего элемента присваивается адрес, который мы ранее запомнили
		ptr->ptrNext = NULL; //  полю со следующим элементом присваиваем NULL
	}
	return ptrFirst; // возвращаем указатель на первый элемент списка

}

void Print(LIST* ptrFirst) // Функция которая выводит все элементы списка на экран
{
	cout << endl << endl;
	LIST* ptr = ptrFirst; // выделение динамической памяти под переменную
	while (ptr != NULL) // проходимся по всем элементам пока указатель ну станет равен NULL
	{
		cout << ptr->inf << "\t"; // выводим информационное поле в консоль
		ptr = ptr->ptrNext; //  переходим к следующему элементу
	}
}

void Edit(LIST* ptrFirst) // функция которая будет удалять каждый четный элемент списка
{
	int count = 1; //  добавляем счетчик
	LIST* ptr = ptrFirst; //  запоминаем первый элемент списка
	
	while (ptr != NULL) // пока элементы существуют то мы проходимся по списку
	{
		if (count % 2 == 0) // если элемент четный заходим в цикл
		{
			LIST* old = ptr; // запоминаем текущий элемент

			LIST* prev = ptr->ptrPrev; //  запоминаем адрес предыдущего элемента
			LIST* next = ptr->ptrNext; //  запоминаем адрес следующего элемента
			prev->ptrNext = next; // у предыдущего элемента в поле которое отвечает за следующий элемент, указываем запомненный ранее элемент
			if (next != NULL) // Проверка на обращение к NULL
			{
				next->ptrPrev = prev; // у следующего элемента в поле, которое отвечает за предыдущий элемент, указываем запомненный ранее элемент
			}
			ptr = ptr->ptrNext; //  переходим к следующему элементу

			delete old; //  удаляем элемент который мы избалили от связей
		}
		else {
			ptr = ptr->ptrNext; // переходим к следующему элементу
		}
		count++; // инкрементируем счетчик
	}
}



int main()
{
	setlocale(LC_ALL, "Ru");
	int size;
	FillS(&size);
	LIST* ptrFirst = Init(size);
	Print(ptrFirst);
	Edit(ptrFirst);
	Print(ptrFirst);

	LIST* ptr = ptrFirst;
	while (ptr != NULL) //  пока указатель не равен NULL, проходимся циклом и удаляем весь список
	{
		ptrFirst = ptr;
		ptr = ptr->ptrNext;
		delete ptrFirst;
	}
}
