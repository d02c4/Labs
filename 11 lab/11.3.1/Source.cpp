#include<iostream>
using namespace std;

struct Stack
{
	double inf; // информационное поле типа double 
	Stack* prev; // поле содержащее адрес предыдущего элемента
};


void InitSize(int *size) // функция для ввода размера стека
{
	cout << "Введите размер стека: \t"; 
	cin >> *size;
	while (*size < 1)
	{
		cout << "Введен некорректный размер стека!" << endl;
		cout << "Введите размер стека: \t";
		cin >> *size;
	}
}

Stack* InitSTACK(int size) // функция создания стека
{
	Stack* top; // создание указателя на верхний элемент стека
	top = new Stack; //  выделение динамической памяти для стека
	cout << "Введите 1 элемент стека:\t";
	cin >> top->inf; // ввод пользоватемем значения информационного поля
	top->prev = NULL; //  указатель на предыдущий элемент верхнего элемента указывает на NULL
	
	for (int  i = 2; i <= size; i++) //  проходимся от 2 до размера массива 
	{
		Stack* h = new Stack; //  выделяем динамическую память под следующие элементы стека
		cout << "Введите "<< i << " элемент стека:\t";
		cin >> h->inf; // заполнение информационного поля очередного элемента стека
		h->prev = top; //  указатель на предыдущий элемент указывает на запомненный элемент
		top = h; //  верхним становится новый элемент, переходим к нему
	}
	return top; //  возвращаем указатель на верхний элемент стека
}

void PrintStack(Stack* top) //  фукнция печати стека в консоль
{
	if (top == NULL) // проверка на существование стека
	{
		cout << "Стек пуст!" << endl;
	}
	else
	{
		Stack* ptr = top; // создаем временную переменную, и приравниваем ее к верхнему элементу стека
		while (ptr != NULL) //  проходимся по всем элементам стека, пока не пройдемся по всем элементам стека
		{
			cout << ptr->inf << " "; //  выводим информационное поле элемента стека в консоль
			ptr = ptr->prev; // переходим к предыдущему элементу стека
		}
		cout << endl;
	}
}

void EditStack(Stack*& top) //  функция изменения стека
{
	Stack* ptr = top; // создаем временную переменную и приравниваем ее к верхнему элементу стека
	Stack* old = nullptr; //  создаем временную переменную которая будет запоминать старый элемент
	while (ptr != NULL) //  проверям на существование текущего элемента
	{
		if (ptr->inf < 0) // если информационное поле элемента стека меньше нуля
		{
			Stack* h = new Stack; // выделяем динамическую память под новую переменную
			h->inf = 0; // в данной переменной информационное поле будет равно 0
			if (old != nullptr) { // проверяем равняется ли запомненная перменная nullptr
				old->prev = h; // в поле которое указывает на предыдущий элемент указываем на новый элемент
			}
			else {
				top = h; // верхним элементом становится новый элемент
			}
			h->prev = ptr; //  в поле, которое указываем на предыдущий элемент, указываем на следующий элемент
		}
		old = ptr; // переходим к следующему элементу стека
		ptr = ptr->prev; //  передвигаем верменный указатель на предыщущий элемент
	}
}


int main()
{
	setlocale(LC_ALL, "Ru");
	int size;
	InitSize(&size);
	Stack* top = InitSTACK(size);
	PrintStack(top);
	EditStack(top);
	PrintStack(top);
}
